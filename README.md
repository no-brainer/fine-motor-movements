# Классификация движений мелкой моторики

* В этом репозитории хранятся исходники сразу двух приложений под платформу Android. Одно из них собирает данные с датчиков движения на мобильном устройстве, а другое демонстрирует работу нейросети, обученной на собранных данных.

* Проект написан на Java и Kotlin с использованием фреймворка TensorFlow Lite. Выбор языков таков из-за платформы, они все таки считаются официальными. TensorFlow Lite необходим для эмбеддинга модели в приложение, поскольку сама модель реализована на TensorFlow.

* Процесс работы приложения для сбора данных:
    1. Пользователь запускает приложение, а затем проходит через этап калибровки датчиков движения. На этом этапе устройство необходимо держать неподвижно, а программа сохраняет значения с датчиков. Предполагается, что ошибка датчиков движения имеет нормальное распределение, поэтому можем воспользоваться несмещенными оценками для параметров этого распределения.
    2. Пользователь может перейти либо в режим последовательности движений, либо записать каждое движение отдельно.
    3. Если была выбрана последовательность движений, то программа через фиксированные промежутки времени выводит название случайного движения, которое пользователь должен выполнить. Собранные данные поправляются при помощи полученного на первом шаге среднеквадратичного отклонения.
    4. Если было выбрано одно движение, то пользователь переключается на экран, где можно выбрать любое движение из выпадающего списка. Затем пользователь должен выполнить это движение за фиксированное время. Собранные данные также поправляются при помощи полученного на первом шаге среднеквадратичного отклонения.

* Процесс работы приложения для классификации:
    0. Вообще в первую очередь необходимо отметить, что в данной версии нейросеть имеет довольно низкую точность на реальных данных.
    1. Пользователь запускает приложение, а затем проходит через этап калибровки датчиков движения. На этом этапе устройство необходимо держать неподвижно, а программа сохраняет значения с датчиков. Предполагается, что ошибка датчиков движения имеет нормальное распределение, поэтому можем воспользоваться несмещенными оценками для параметров этого распределения.
    2. Пользователь переходит в режим классификации. Здесь нужно выполнять движения мелкой моторики. Нейросеть выносит вердикт, базируясь на фиксированном количестве последних показаний.
    3. Полученные с датчиков показания помещаются в дек для того, чтобы можно было подсмотреть последнее показание в структуре, добавить новое показание в конец или удалить старое показание из начала дека.
    4. Если в деке накапливается необходимое количество показаний, то значения копируются в массив (но не удаляются, здесь используется метод скользящего окна!), а затем скармливаются нейросети. Первое значение из дека удаляется.
    5. Нейросеть выполняет свои задачи на заднем плане, дабы не перебивать основной программы. Как только результат посчитан, то на экран выводятся три наиболее вероятных класса, а название движения с наибольшей вероятностью объявляется голосом.
